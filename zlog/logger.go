package zlog

import (
	"github.com/PandaTtttt/go-assembly/env"
	"github.com/PandaTtttt/go-assembly/util/must"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"io"
	"os"
	"sync"
	"time"
)

// LogWriter is a io.Writer with a callback method.
type LogWriter interface {
	io.Writer
	// callback receives a Logger generated by LogWriter
	// it's used to validate or initialize LogWriter.
	callback(*Logger) error
}

// AddCallback converts an io.Writer to a LogWriter. It attempts to be
// intelligent: if the concrete type of the io.Writer implements LogWriter,
// we'll use the existing callback method. If it doesn't, we'll add a no-op callback.
func AddCallback(w io.Writer) LogWriter {
	switch w := w.(type) {
	case LogWriter:
		return w
	default:
		return writerWrapper{w}
	}
}

type writerWrapper struct {
	io.Writer
}

func (w writerWrapper) callback(*Logger) error {
	return nil
}

type Logger struct {
	*zap.Logger
	mu sync.Mutex
}

var std = func() *Logger {
	logger, err := zap.NewDevelopment()
	must.Must(err)
	return &Logger{Logger: logger}
}()

func SetLogger(logger *Logger) {
	std.mu.Lock()
	defer std.mu.Unlock()
	std = logger
}

type Config struct {
	Info []LogWriter
	Err  []LogWriter
}

// Init initializes global standard Logger by given config,
// it should be called from init function in main package.
func Init(conf Config) {
	std.mu.Lock()
	defer std.mu.Unlock()

	encoderConf := zap.NewProductionEncoderConfig()
	encoderConf.TimeKey = "timestamp"
	encoderConf.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
		nanos := t.UnixNano()
		millis := nanos / int64(time.Millisecond)
		enc.AppendInt64(millis)
	}
	encoderConf.EncodeDuration = zapcore.MillisDurationEncoder

	logger, err := New(conf, encoderConf, zap.AddCaller(), zap.AddCallerSkip(1))
	must.Must(err)
	std = logger
}

func New(logConf Config, encoderConf zapcore.EncoderConfig, opts ...zap.Option) (*Logger, error) {
	goEnv := os.Getenv(env.GoEnv)
	if goEnv == env.DevelopMode || goEnv == "" {
		logger, err := zap.NewDevelopment(opts...)
		if err != nil {
			return nil, err
		}
		return &Logger{Logger: logger}, nil
	}

	encoder := zapcore.NewJSONEncoder(encoderConf)

	var cores []zapcore.Core

	infoLevel := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool {
		return lvl == zapcore.InfoLevel
	})
	for _, w := range logConf.Info {
		writer := zapcore.Lock(zapcore.AddSync(w))
		core := zapcore.NewCore(encoder, writer, infoLevel)
		cores = append(cores, core)
	}

	errLevel := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool {
		return lvl >= zapcore.WarnLevel
	})
	for _, w := range logConf.Err {
		writer := zapcore.Lock(zapcore.AddSync(w))
		core := zapcore.NewCore(encoder, writer, errLevel)
		cores = append(cores, core)
	}

	core := zapcore.NewTee(cores...)
	logger := &Logger{Logger: zap.New(core).WithOptions(opts...)}

	for _, w := range logConf.Info {
		err := w.callback(logger)
		if err != nil {
			return nil, err
		}
	}

	for _, w := range logConf.Err {
		err := w.callback(logger)
		if err != nil {
			return nil, err
		}
	}

	return logger, nil
}

func Debug(msg string, fields ...zap.Field) {
	std.Debug(msg, fields...)
}

func Info(msg string, fields ...zap.Field) {
	std.Info(msg, fields...)
}

func Warn(msg string, fields ...zap.Field) {
	std.Warn(msg, fields...)
}

func Error(msg string, fields ...zap.Field) {
	std.Error(msg, fields...)
}

func DPanic(msg string, fields ...zap.Field) {
	std.DPanic(msg, fields...)
}

func Panic(msg string, fields ...zap.Field) {
	std.Panic(msg, fields...)
}

func Fatal(msg string, fields ...zap.Field) {
	std.Fatal(msg, fields...)
}
